name: Release

on:
  workflow_dispatch:
    inputs:
      images:
        description: 'Comma-separated list of images to release (e.g. "centos7-oj8,hdp3.1-hive")'
        required: true
        type: 'string'
      tag_latest:
        description: 'Tag the published images as latest'
        type: boolean
        default: true
        required: false

env:
  GIT_CI_USER: ${{ vars.GIT_CI_USER || 'prestodb-ci' }}
  GIT_CI_EMAIL: ${{ vars.GIT_CI_EMAIL || 'ci@lists.prestodb.io' }}
  LOCAL_IMAGES: ${{ vars.LOCAL_IMAGES || '' }}
  MULTI_IMAGES: ${{ vars.MULTI_IMAGES || '' }}

jobs:
  validate-branch:
    name: Validate branch
    runs-on: ubuntu-latest
    steps:
      - name: Check branch name
        run: |
          BRANCH_NAME="${{ github.ref }}"
          echo "Branch: ${BRANCH_NAME}"

          if [[ "${BRANCH_NAME}" == "refs/heads/master" ]] || \
             [[ "${BRANCH_NAME}" == refs/heads/release-* ]] || \
             [[ "${BRANCH_NAME}" == refs/heads/patch-* ]]; then
            echo "✓ Branch is allowed: ${BRANCH_NAME}"
          else
            echo "✗ Error: Release workflow can only be run on master, release-*, or patch-* branches"
            echo "  Current branch: ${BRANCH_NAME}"
            exit 1
          fi

  release-branch:
    name: Prepare release branch
    needs: [validate-branch]
    if: ${{ github.ref == 'refs/heads/master' }}
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
    outputs:
      release_version: ${{ steps.release_tag.outputs.release_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRESTODB_CI_TOKEN }}
          show-progress: false

      - name: Configure Git
        run: |
          git config --global user.email "${{ env.GIT_CI_EMAIL }}"
          git config --global user.name "${{ env.GIT_CI_USER }}"
          git config --global alias.ls 'log --pretty=format:"%cd %h %ce: %s" --date=short --no-merges'
          git ls -5

      - name: Create release branch and tag
        id: release_tag
        run: |
          CURRENT_VERSION=$(grep "VERSION :=" Makefile | sed 's/VERSION := //' | sed 's/-SNAPSHOT//')
          NEW_VERSION=${CURRENT_VERSION}

          # Create release branch
          git checkout -b release-${NEW_VERSION}

          # Update version in Makefile
          sed -i "s/VERSION := .*/VERSION := ${NEW_VERSION}/" Makefile
          echo "release_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          git add Makefile
          git commit -m "[release-action] release version ${NEW_VERSION}"
          git ls -5

          # Create release tag
          git tag -a -m "Release version ${NEW_VERSION}" ${NEW_VERSION}

          # Push release branch and tag
          git push origin release-${NEW_VERSION} --tags

          # Switch back to master for next snapshot version
          git checkout master

      - name: Prepare next snapshot version
        run: |
          sed -i "s/VERSION := .*/VERSION := $((${{ steps.release_tag.outputs.release_version }} + 1))-SNAPSHOT/" Makefile
          git add Makefile
          git commit -m "[release-action] prepare for next development iteration"
          git ls -5
          git push origin master

  publish-images:
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
    needs: [validate-branch, release-branch]
    if: (!failure() && !cancelled())
    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.images }}" ]; then
            echo "Error: Image names are required."
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          show-progress: false

      - name: Determine release version
        run: |
          if [ "${{ github.ref }}" = "refs/heads/master" ]; then
            # New release from master
            echo "RELEASE_VERSION=${{ needs.release-branch.outputs.release_version }}" >> $GITHUB_ENV
          else
            # Publishing from release/patch branch - extract version from Makefile
            RELEASE_VERSION=$(grep "VERSION :=" Makefile | sed 's/VERSION := //' | sed 's/-SNAPSHOT//')
            echo "RELEASE_VERSION=${RELEASE_VERSION}" >> $GITHUB_ENV
          fi
          echo "Release version: ${{ env.RELEASE_VERSION }}"

      - name: Configure Git
        run: |
          git config --global user.email "${{ env.GIT_CI_EMAIL }}"
          git config --global user.name "${{ env.GIT_CI_USER }}"
          git config --global alias.ls 'log --pretty=format:"%cd %h %ce: %s" --date=short --no-merges'
          git ls -5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Release Selected Images
        env:
          RELEASE_VERSION: ${{ env.RELEASE_VERSION }}
          DOCKER_ORG: ${{ github.repository_owner }}
          LOCAL_IMAGES: ${{ env.LOCAL_IMAGES }}
          MULTI_IMAGES: ${{ env.MULTI_IMAGES }}
        run: |
          IMAGES="${{ github.event.inputs.images }}"

          IFS=',' read -ra IMAGE_ARRAY <<< "$IMAGES"
          IFS=',' read -ra LOCAL_ARRAY <<< "$LOCAL_IMAGES"
          IFS=',' read -ra MULTI_ARRAY <<< "$MULTI_IMAGES"

          # Function to check if image is in array
          contains() {
            local item="$1"
            shift
            for elem in "$@"; do
              [[ "$elem" == "$item" ]] && return 0
            done
            return 1
          }

          for IMAGE in "${IMAGE_ARRAY[@]}"; do
            echo "Processing image: $IMAGE"

            if contains "$IMAGE" "${MULTI_ARRAY[@]}"; then
              echo "Building multi-arch image: $IMAGE"
              make "prestodb/$IMAGE@multi" DOCKER_ORG="${DOCKER_ORG}" VERSION="${RELEASE_VERSION}"
              echo "Multi-arch image built and pushed"

            elif contains "$IMAGE" "${LOCAL_ARRAY[@]}"; then
              echo "Building local single-arch image: $IMAGE"
              make "prestodb/$IMAGE@local"

              # Tag and push the local image
              echo "Tagging and pushing image: $IMAGE"
              docker tag "prestodb/$IMAGE:latest" "${DOCKER_ORG}/$IMAGE:${RELEASE_VERSION}"
              docker push "${DOCKER_ORG}/$IMAGE:${RELEASE_VERSION}"

              if [ "${{ github.event.inputs.tag_latest }}" = "true" ]; then
                docker tag "prestodb/$IMAGE:latest" "${DOCKER_ORG}/$IMAGE:latest"
                docker push "${DOCKER_ORG}/$IMAGE:latest"
              fi

            else
              echo "Image $IMAGE not found in LOCAL_IMAGES or MULTI_IMAGES variables"
              make "prestodb/$IMAGE"

              docker tag "prestodb/$IMAGE:latest" "${DOCKER_ORG}/$IMAGE:${RELEASE_VERSION}"
              docker push "${DOCKER_ORG}/$IMAGE:${RELEASE_VERSION}"

              if [ "${{ github.event.inputs.tag_latest }}" = "true" ]; then
                docker tag "prestodb/$IMAGE:latest" "${DOCKER_ORG}/$IMAGE:latest"
                docker push "${DOCKER_ORG}/$IMAGE:latest"
              fi
            fi

            echo "Completed processing: $IMAGE"
          done